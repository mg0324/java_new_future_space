import{_ as s,o as i,c as n,ae as l}from"./chunks/framework.Dn7Y7LSn.js";const c=JSON.parse('{"title":"Java 15 新特性总结","description":"","frontmatter":{},"headers":[],"relativePath":"java15新特性.md","filePath":"java15新特性.md"}'),e={name:"java15新特性.md"};function h(t,a,p,k,r,d){return i(),n("div",null,[...a[0]||(a[0]=[l(`<h1 id="java-15-新特性总结" tabindex="-1">Java 15 新特性总结 <a class="header-anchor" href="#java-15-新特性总结" aria-label="Permalink to &quot;Java 15 新特性总结&quot;">​</a></h1><p>Java 15 是 Oracle 于 2020 年 9 月 15 日发布的版本，虽然不是长期支持（LTS）版本，但带来了 14 个新功能，其中有不少是十分实用的特性。Java 15 在语言特性、JVM 改进和 API 增强等方面都有显著的提升。</p><h2 id="主要新特性" tabindex="-1">主要新特性 <a class="header-anchor" href="#主要新特性" aria-label="Permalink to &quot;主要新特性&quot;">​</a></h2><h3 id="_1-密封类-sealed-classes-预览特性" tabindex="-1">1. 密封类（Sealed Classes，预览特性） <a class="header-anchor" href="#_1-密封类-sealed-classes-预览特性" aria-label="Permalink to &quot;1. 密封类（Sealed Classes，预览特性）&quot;">​</a></h3><p>密封类允许开发者对继承进行更精细的控制，提供了一种更加精确地控制类继承的方法。类的设计者可以指定一个类能够被哪些类继承，增强了类的封装性和安全性。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 sealed 关键字限制继承</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Shape</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    permits</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Circle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Square</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Circle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Shape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Square</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Shape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">non-sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rectangle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Shape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_2-文本块-text-blocks-正式特性" tabindex="-1">2. 文本块（Text Blocks，正式特性） <a class="header-anchor" href="#_2-文本块-text-blocks-正式特性" aria-label="Permalink to &quot;2. 文本块（Text Blocks，正式特性）&quot;">​</a></h3><p>经过两次预览，Text Blocks 在 Java 15 成为正式特性，使多行字符串处理不再繁琐。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用文本块定义多行字符串</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String html </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">             &lt;html&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                 &lt;body&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                     &lt;p&gt;Hello, world&lt;/p&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                 &lt;/body&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">             &lt;/html&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">             &quot;&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="_3-records-二次预览" tabindex="-1">3. Records（二次预览） <a class="header-anchor" href="#_3-records-二次预览" aria-label="Permalink to &quot;3. Records（二次预览）&quot;">​</a></h3><p>Records 特性在 Java 15 中继续作为预览特性，可以用来简化对象的创建和访问，自动生成 getter 和其他必要的方法。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 Records 简化数据载体类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> record</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String name, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getAge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_4-instanceof-模式匹配-二次预览" tabindex="-1">4. instanceof 模式匹配（二次预览） <a class="header-anchor" href="#_4-instanceof-模式匹配-二次预览" aria-label="Permalink to &quot;4. instanceof 模式匹配（二次预览）&quot;">​</a></h3><p>instanceof 模式匹配在 Java 15 中继续作为预览特性，简化了类型检查和转换的过程。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用模式匹配简化类型检查</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String str) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUpperCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动转换为 String 类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_5-隐藏类-hidden-classes" tabindex="-1">5. 隐藏类（Hidden Classes） <a class="header-anchor" href="#_5-隐藏类-hidden-classes" aria-label="Permalink to &quot;5. 隐藏类（Hidden Classes）&quot;">​</a></h3><p>Java 15 引入了隐藏类（Hidden Classes）特性，可以用来隐藏类的实现细节。隐藏类不能被其他类直接引用，主要用于框架和库的内部实现。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 隐藏类主要用于框架实现，普通开发者较少直接使用</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 但可以提高框架的性能和灵活性</span></span></code></pre></div><h2 id="jvm-相关改进" tabindex="-1">JVM 相关改进 <a class="header-anchor" href="#jvm-相关改进" aria-label="Permalink to &quot;JVM 相关改进&quot;">​</a></h2><h3 id="_1-zgc-可扩展低延迟垃圾收集器-正式发布" tabindex="-1">1. ZGC: 可扩展低延迟垃圾收集器（正式发布） <a class="header-anchor" href="#_1-zgc-可扩展低延迟垃圾收集器-正式发布" aria-label="Permalink to &quot;1. ZGC: 可扩展低延迟垃圾收集器（正式发布）&quot;">​</a></h3><p>ZGC 在 Java 15 中正式发布，不再处于实验阶段，提供可扩展的低延迟垃圾收集功能。</p><ul><li>停顿时间不超过 10 毫秒</li><li>支持 TB 级别的堆内存</li><li>适用于需要低延迟的大规模应用程序</li></ul><h3 id="_2-shenandoah-gc-正式发布" tabindex="-1">2. Shenandoah GC（正式发布） <a class="header-anchor" href="#_2-shenandoah-gc-正式发布" aria-label="Permalink to &quot;2. Shenandoah GC（正式发布）&quot;">​</a></h3><p>Shenandoah 垃圾收集器在 Java 15 中正式发布，提供低停顿时间的垃圾收集功能。</p><h3 id="_3-禁用和废弃偏向锁-biased-locking" tabindex="-1">3. 禁用和废弃偏向锁（Biased Locking） <a class="header-anchor" href="#_3-禁用和废弃偏向锁-biased-locking" aria-label="Permalink to &quot;3. 禁用和废弃偏向锁（Biased Locking）&quot;">​</a></h3><p>Java 15 开始禁用和废弃偏向锁（Biased Locking），这是为了未来的性能优化做准备。</p><h3 id="_4-重新实现-datagramsocket-api" tabindex="-1">4. 重新实现 DatagramSocket API <a class="header-anchor" href="#_4-重新实现-datagramsocket-api" aria-label="Permalink to &quot;4. 重新实现 DatagramSocket API&quot;">​</a></h3><p>Java 15 重新实现了 DatagramSocket API，使其更加现代化和易于维护。</p><h2 id="api-增强" tabindex="-1">API 增强 <a class="header-anchor" href="#api-增强" aria-label="Permalink to &quot;API 增强&quot;">​</a></h2><h3 id="_1-外部内存访问-api-第二个孵化器" tabindex="-1">1. 外部内存访问 API（第二个孵化器） <a class="header-anchor" href="#_1-外部内存访问-api-第二个孵化器" aria-label="Permalink to &quot;1. 外部内存访问 API（第二个孵化器）&quot;">​</a></h3><p>Java 15 继续提供外部内存访问 API 的孵化器版本，允许更安全地访问 JVM 外部内存。</p><h3 id="_2-爱德华曲线算法-eddsa" tabindex="-1">2. 爱德华曲线算法（EdDSA） <a class="header-anchor" href="#_2-爱德华曲线算法-eddsa" aria-label="Permalink to &quot;2. 爱德华曲线算法（EdDSA）&quot;">​</a></h3><p>Java 15 增加了一个新的密码学算法，爱德华曲线算法（EdDSA）签名算法。</p><h2 id="已删除和移除的功能" tabindex="-1">已删除和移除的功能 <a class="header-anchor" href="#已删除和移除的功能" aria-label="Permalink to &quot;已删除和移除的功能&quot;">​</a></h2><h3 id="_1-移除-nashorn-javascript-引擎" tabindex="-1">1. 移除 Nashorn JavaScript 引擎 <a class="header-anchor" href="#_1-移除-nashorn-javascript-引擎" aria-label="Permalink to &quot;1. 移除 Nashorn JavaScript 引擎&quot;">​</a></h3><p>Java 15 正式移除了 Nashorn JavaScript 引擎，这是因为在 GraalVM 提供了更好的替代方案。</p><h3 id="_2-删除-solaris-和-sparc-端口" tabindex="-1">2. 删除 Solaris 和 SPARC 端口 <a class="header-anchor" href="#_2-删除-solaris-和-sparc-端口" aria-label="Permalink to &quot;2. 删除 Solaris 和 SPARC 端口&quot;">​</a></h3><p>由于缺乏足够的维护资源，Solaris 和 SPARC 端口在 Java 15 中被完全删除。</p><h2 id="预览和孵化器功能" tabindex="-1">预览和孵化器功能 <a class="header-anchor" href="#预览和孵化器功能" aria-label="Permalink to &quot;预览和孵化器功能&quot;">​</a></h2><h3 id="_1-密封类-sealed-classes" tabindex="-1">1. 密封类（Sealed Classes） <a class="header-anchor" href="#_1-密封类-sealed-classes" aria-label="Permalink to &quot;1. 密封类（Sealed Classes）&quot;">​</a></h3><ul><li>作为预览特性引入</li><li>提供更精确的类继承控制</li><li>增强类的封装性和安全性</li></ul><h3 id="_2-records-二次预览" tabindex="-1">2. Records（二次预览） <a class="header-anchor" href="#_2-records-二次预览" aria-label="Permalink to &quot;2. Records（二次预览）&quot;">​</a></h3><ul><li>简化数据载体类的定义</li><li>自动生成构造函数、访问器方法、equals、hashCode 和 toString 方法</li></ul><h3 id="_3-instanceof-模式匹配-二次预览" tabindex="-1">3. instanceof 模式匹配（二次预览） <a class="header-anchor" href="#_3-instanceof-模式匹配-二次预览" aria-label="Permalink to &quot;3. instanceof 模式匹配（二次预览）&quot;">​</a></h3><ul><li>简化类型检查和转换过程</li><li>减少样板代码</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Java 15 虽然是短期版本，但特性相当丰富。其中最引人注目的是文本块在这一版终于正式发布，使多行字符串处理不再繁琐。密封类的引入为开发者提供了更精确的继承控制机制，隐藏类为框架开发者提供了更灵活的实现方式。</p><p>Java 15 还在性能和 JVM 改进方面做了很多工作，包括 ZGC 和 Shenandoah GC 的正式发布，这为低延迟应用场景提供了更多选择。同时，移除 Nashorn JavaScript 引擎等决策也表明了 Java 平台向前发展的决心。</p><p>这些新特性的引入，标志着 Java 语言正在向更现代化、更安全和更高效的方向发展。</p>`,49)])])}const g=s(e,[["render",h]]);export{c as __pageData,g as default};
