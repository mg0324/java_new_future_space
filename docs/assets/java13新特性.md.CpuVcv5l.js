import{_ as s,o as i,c as l,ae as t}from"./chunks/framework.DLxmGODj.js";const c=JSON.parse('{"title":"Java 13 新特性总结","description":"","frontmatter":{},"headers":[],"relativePath":"java13新特性.md","filePath":"java13新特性.md"}'),n={name:"java13新特性.md"};function e(h,a,p,k,r,d){return i(),l("div",null,[...a[0]||(a[0]=[t(`<h1 id="java-13-新特性总结" tabindex="-1">Java 13 新特性总结 <a class="header-anchor" href="#java-13-新特性总结" aria-label="Permalink to &quot;Java 13 新特性总结&quot;">​</a></h1><p>Java 13 是 Oracle 于 2019 年 9 月 17 日发布的版本，虽然不是长期支持（LTS）版本，但也带来了不少重要的新功能和改进。Java 13 继续沿用了每六个月发布一个新版本的策略，并重点增强了性能和语言表达能力。</p><h2 id="主要新特性" tabindex="-1">主要新特性 <a class="header-anchor" href="#主要新特性" aria-label="Permalink to &quot;主要新特性&quot;">​</a></h2><h3 id="_1-文本块-text-blocks-预览特性" tabindex="-1">1. 文本块（Text Blocks，预览特性） <a class="header-anchor" href="#_1-文本块-text-blocks-预览特性" aria-label="Permalink to &quot;1. 文本块（Text Blocks，预览特性）&quot;">​</a></h3><p>Java 13 引入了文本块作为预览特性，这是一个多行字符串文字，它避免了对大多数转义序列的需要，以可预测的方式自动格式化字符串，并在需要时让开发人员控制格式。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传统的多行字符串写法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String html </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&lt;html&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">              &quot;    &lt;body&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">              &quot;        &lt;p&gt;Hello, world&lt;/p&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">              &quot;    &lt;/body&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">              &quot;&lt;/html&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Java 13 的文本块写法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String html </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">              &lt;html&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                  &lt;body&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                      &lt;p&gt;Hello, world&lt;/p&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                  &lt;/body&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">              &lt;/html&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">              &quot;&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>文本块使用三个双引号 (<code>&quot;&quot;&quot;</code>) 作为分隔符，使得多行字符串的编写更加简洁和易读。</p><h3 id="_2-switch-表达式增强-二次预览" tabindex="-1">2. Switch 表达式增强（二次预览） <a class="header-anchor" href="#_2-switch-表达式增强-二次预览" aria-label="Permalink to &quot;2. Switch 表达式增强（二次预览）&quot;">​</a></h3><p>Java 13 对在 Java 12 中首次引入的 Switch 表达式进行了增强，引入了 <code>yield</code> 语句来返回值，而不是使用 <code>break</code>。<code>yield</code> 关键字用于从 switch 表达式的 case 块中返回一个值。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 yield 从 switch 表达式返回值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (day) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MONDAY, TUESDAY </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> WEDNESDAY </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Wednesday&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        yield</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 yield 返回值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="_3-动态-cds-归档-dynamic-cds-archives" tabindex="-1">3. 动态 CDS 归档（Dynamic CDS Archives） <a class="header-anchor" href="#_3-动态-cds-归档-dynamic-cds-archives" aria-label="Permalink to &quot;3. 动态 CDS 归档（Dynamic CDS Archives）&quot;">​</a></h3><p>Java 13 扩展了应用程序类-数据共享（AppCDS），以允许在 Java 应用程序执行结束时动态归档类。归档类将包括默认的基础层 CDS 存档中不存在的所有已加载的应用程序类和库类。</p><ul><li>提升应用程序启动性能</li><li>减少内存占用</li><li>延续了在 Java 10 中引入的 AppCDS 功能</li></ul><h3 id="_4-zgc-释放未使用的内存-zgc-uncommit-unused-memory" tabindex="-1">4. ZGC：释放未使用的内存（ZGC: Uncommit Unused Memory） <a class="header-anchor" href="#_4-zgc-释放未使用的内存-zgc-uncommit-unused-memory" aria-label="Permalink to &quot;4. ZGC：释放未使用的内存（ZGC: Uncommit Unused Memory）&quot;">​</a></h3><p>Java 13 增强了 ZGC，使其能够将未使用的堆内存返回给操作系统。ZGC 是一个可扩展的低延迟垃圾收集器，在 Java 13 中进一步优化了内存管理。</p><ul><li>减少应用程序的内存占用</li><li>提高内存使用效率</li><li>适用于需要低延迟的大规模应用程序</li></ul><h3 id="_5-重新实现-socket-api-reimplement-the-legacy-socket-api" tabindex="-1">5. 重新实现 Socket API（Reimplement the Legacy Socket API） <a class="header-anchor" href="#_5-重新实现-socket-api-reimplement-the-legacy-socket-api" aria-label="Permalink to &quot;5. 重新实现 Socket API（Reimplement the Legacy Socket API）&quot;">​</a></h3><p>Java 13 使用更简单、更现代的实现替换了 java.net.Socket 和 java.net.ServerSocket API 使用的底层实现，以提高可维护性和调试性。</p><ul><li>简化了 Socket API 的底层实现</li><li>提高了可维护性</li><li>便于调试和故障排除</li></ul><h2 id="预览和实验性功能" tabindex="-1">预览和实验性功能 <a class="header-anchor" href="#预览和实验性功能" aria-label="Permalink to &quot;预览和实验性功能&quot;">​</a></h2><h3 id="文本块-text-blocks" tabindex="-1">文本块（Text Blocks） <a class="header-anchor" href="#文本块-text-blocks" aria-label="Permalink to &quot;文本块（Text Blocks）&quot;">​</a></h3><ul><li>作为预览特性引入</li><li>提供了多行字符串字面量的简洁语法</li><li>自动处理字符串格式化</li></ul><h3 id="switch-表达式-增强版" tabindex="-1">Switch 表达式（增强版） <a class="header-anchor" href="#switch-表达式-增强版" aria-label="Permalink to &quot;Switch 表达式（增强版）&quot;">​</a></h3><ul><li>在 Java 12 的基础上进行了增强</li><li>引入了 <code>yield</code> 语句用于返回值</li><li>继续作为预览特性提供</li></ul><h2 id="其他改进" tabindex="-1">其他改进 <a class="header-anchor" href="#其他改进" aria-label="Permalink to &quot;其他改进&quot;">​</a></h2><h3 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h3><ul><li>通过动态 CDS 归档提升启动性能</li><li>通过 ZGC 改进内存管理</li><li>通过 Socket API 重构提高可维护性</li></ul><h3 id="jvm-改进" tabindex="-1">JVM 改进 <a class="header-anchor" href="#jvm-改进" aria-label="Permalink to &quot;JVM 改进&quot;">​</a></h3><ul><li>更好的内存管理机制</li><li>优化的垃圾收集行为</li><li>改进的类加载机制</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Java 13 虽然不是长期支持版本，但仍然引入了一些非常有用的功能，特别是文本块和 Switch 表达式的增强，显著改善了 Java 代码的可读性和表达能力。动态 CDS 归档和 ZGC 的改进则进一步提升了性能表现。</p><p>Java 13 的发布延续了 Java 平台不断演进的趋势，通过预览特性的引入，允许开发者提前体验并反馈，确保新功能在正式发布前经过充分验证。文本块的引入使得处理多行字符串变得更加直观，而 Switch 表达式的改进则让条件逻辑的编写更加简洁。</p>`,32)])])}const g=s(n,[["render",e]]);export{c as __pageData,g as default};
